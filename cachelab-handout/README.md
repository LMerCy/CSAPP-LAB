# cacheLab PART A

解题思路：

解析命令 -> 初始化缓存模型 -> 获取内存读取信息 ->  缓存

### 1. 解析命令

使用getopt函数

### 2. 初始化缓存模型

首先构建和缓存相关的数据结构：cacheLine -> set -> cache

cacheline中包含标志位，有效位

set中就是cacheline的指针

cache中包含set的个数，以及每个set中cacheline的个数

初始化函数，首先从命令中获取s,E,b参数，根据三个参数分别确定Set的个数 = 1L << s;cacheline的个数 E ,因为不取数据，所以b是不需要的。初始化时使用malloc来分别分配cachline和set的内存。

### 3. 获取内存读取信息

按行读取文件内容，并对每行进行操作。注意文件中提供的地址是16进制的！

### 4. 缓存
0. 根据内存地址解析出cachline的信息。
1. 然后利用setindex来迅速定位在哪一个set，之后遍历set内部的cacheline来查看是否命中。
2. 不命中的话，首先看该set内有没有有效位为0的cacheline，有的话直接更新，不产生eviction；没有的话采取lru来选择牺牲行进行替换。
3. 实现lru的方法是在每个cacheline设置一个上一次使用的时间和一个全局的time，每次进行缓存操作时将这个time+1，并将这个time更新到对应的cacheline中。进行lru时，替换组内time最小的cacheline。


# Cache Lab Part B

## 32*32 


### 1. 为什么使用8*8来做为分块
（s,E,b） = (5,1,5),表示该缓存有32组，每组32个字节，每组一个cacheline，也就是说每一组刚好缓存8个int数。而整个cache可以刚好放下8*32个int数。

首先对于32\*32的数组,8行数据会刚好完全占满整个cache，每个数据加载到哪个缓存组中是由其地址决定的，不是哪个组有空的就加载到哪个组内，只有当组内有多个cacheline时，可以选择加载到空的cacheline中。

因此选择8行小矩阵，可以保证在整个小矩阵内不发生替换。选择8列比较好理解，一次加载可以保证8个数都在同一个cacheline中，不产生第二次miss。

（内存是连续存储的，同样缓存加载位置也是连续的，8*8的小矩阵的行不会缓存在相邻的8个set中。）

### 2. 命中率计算

同时需要注意A和B的每一行是占用同一组cache的，原因是A和B的大小刚好都是cache大小的整数倍，因此将他们加载到缓存中会出现每一行都占用同一个缓存组的情况。

对于非对角线的block矩阵，每一次A的加载都是1/8miss率，对于B的加载，由于此时A和B的子矩阵肯定不会在同一行，所以不会占用同一个cache组，因此总的miss数为：

```math
12*64*2*1/8 = 192
```
对于对角线的block矩阵，首先B的第一列数据肯定是miss的，但是在下一个循环中，若A新加载一行数据，会造成B的一行数据被覆盖，导致B的每一行其实会有两个数据miss（除了第一行）,也就是miss率为1/4。
```math
4*64*(1/8+1/4) - 4 = 92
```
一共是192+92=284次miss。

实际实验的miss为287，非常接近理论数据。

## 64*64

### 1.block大小

若设置block大小为4\*4，miss数可以大概估计最少为：
16\*16\*16\*2\*1/4= 2048 ，无法通过。

看了下其他网友的做法，好的做法基本上就是依然以8\*8的block为基础，将这个8\*8的block再划分为4个4\*4的矩阵，即：
```
A（8*8）:       B（8*8）:                 
a0 | a1         b0 | b1           
a2 | a3         b2 | b3             
```
首先将a0转置到b0,再将a1转置到b1，整个过程中B矩阵的上半部分将占据整个cache，并得到了充分的利用。

再将b1的值转置到b2，同时将a2转职到b1。注意此时是A的下半部分将占据整个cache，也就是说a2是以列来读取，而B是以行来读取存放。

最后对a3已保存在cache中，以列来读取a3，以行来保存至b3。

### 2.miss数计算


实验miss数1219。



## 61*67

因为此处miss要求较低，直接使用第一个方法，将block设置为16*16即可。

miss数位1992。

满分通过。